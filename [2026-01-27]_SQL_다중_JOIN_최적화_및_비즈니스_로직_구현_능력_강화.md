# [2026-01-27] SQL 다중 JOIN 및 대용량 데이터 집계 전략 학습

## 1. 오늘 학습 요약 (Key Accomplishments)
- 복잡한 ERD 구조 내에서 다중 테이블(5개 이상) 간의 관계를 매핑하고 데이터 추출 성공.
- 데이터 정합성 확인을 위한 불일치 쿼리(Left Join) 및 통계 쿼리(Aggregation) 숙달.

## 2. 핵심 기술 개념 (Technical Deep Dive)
- **JOIN 성능 최적화:** 1:N, M:N 관계에서 중간 매핑 테이블(`film_actor`, `film_category`)의 역할을 파악하고, 불필요한 스캔을 줄이기 위한 JOIN 순서 고려.
- **Filtering Strategy:** 데이터 세트가 커질수록 `WHERE`에서 먼저 데이터를 쳐내고, `GROUP BY` 후 필요한 결과만 `HAVING`으로 거르는 것이 성능 최적화의 핵심임을 인지함.
- **CTE(Common Table Expressions):** 복잡한 서브쿼리를 `WITH` 절로 정의하여 코드의 선언적 의미를 강화하고 가독성을 높임.

## 3. 코드 리뷰 및 성능 분석 (Code Review)

#### [Case 1] 다중 그룹화 및 데이터 밀도 분석
```sql
-- 배우별, 영화 등급별 출연 빈도 분석
SELECT 
    a.actor_id, 
    a.first_name, 
    f.rating, 
    COUNT(*) AS appearance_count
FROM actor a
JOIN film_actor fa ON a.actor_id = fa.actor_id
JOIN film f ON fa.film_id = f.film_id
GROUP BY a.actor_id, a.first_name, f.rating
ORDER BY a.actor_id ASC;
```
- **성능 분석:** `actor_id`를 PK로 활용하여 그룹화함으로써 인덱스 효율을 높임. `rating` 별 분포를 통해 특정 배우의 선호 장르/등급 파악 가능.

#### [Case 2] 예외 데이터(Missing Data) 탐지
```sql
-- 재고(Inventory) 유실 영화 식별
SELECT f.film_id, f.title
FROM film f
LEFT JOIN inventory i ON f.film_id = i.inventory_id
WHERE i.inventory_id IS NULL;
```
- **비즈니스 가치:** 실무에서 '판매되지 않는 상품'이나 '누락된 재고'를 파악할 때 필수적인 패턴. 인덱스 설정 여부에 따라 `NOT EXISTS` 구문과 성능 비교가 필요함.

## 4. 트러블슈팅 및 해결 (Troubleshooting)
- **이슈:** `GROUP BY` 절에 집계 함수가 아닌 일반 컬럼이 누락되어 `non-aggregated column` 에러 발생.
- **해결:** SQL 표준 문법에 따라 `SELECT` 리스트의 모든 비집계 컬럼을 `GROUP BY`에 명시하여 데이터의 고유성을 보장함.
- **교훈:** 별칭(Alias) 사용 시 마침표(.)를 사용하면 스키마 식별자로 오인될 수 있음을 확인하고 공백 구분을 철저히 함.

## 5. AI 서비스 개발 및 RAG 관점의 통찰
- **RAG를 위한 SQL Agent 설계:** 대규모 DB를 사용하는 RAG 시스템에서 LLM이 오늘처럼 복잡한 쿼리를 작성하게 하려면, 테이블 간의 **Foreign Key 관계 정보(Metadata)**가 정교하게 제공되어야 함.
- **Semantic Search 연동:** 사용자가 "가장 인기 있는 카테고리"를 물을 때, 오늘 구현한 9번/15번 쿼리처럼 다중 JOIN을 통해 정확한 수치를 도출하는 구조가 AI의 답변 신뢰도를 결정함.