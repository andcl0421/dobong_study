#### [오늘 학습 요약: 사용자 설계 중심 ERD 고도화]

- 기초적인 1:N 관계에서 시작하여, 실무 수준의 복합적인 N:M 관계까지 ERD 설계를 확장함.
- 데이터의 중복을 방지하고 검색 효율을 높이기 위한 정규화 과정을 시각화함.

## 1. 배운 개념 정리 (설계안 분석)

### [계층적 구조의 진화]
- **기초**: Singer → Album → Song으로 이어지는 단방향 흐름 이해.
- **심화**: 한 노래에 여러 가수가 참여하거나, 한 앨범이 여러 장르에 속하는 복잡한 관계를 중계 테이블로 해결함.

### [중계 테이블(Junction Table)의 도입]
- **정의**: 두 테이블의 PK를 FK로 가져와서 관계를 맺어주는 보조 테이블.
- **활용**: `Song_Singer` 테이블을 통해 특정 노래의 '메인/피처링' 역할을 구분하여 저장 가능.

## 2. 오늘 작성한 ERD 리뷰 (업로드 이미지 기반)

### [그림 1, 2: 기본 관계 설정]
- `SingerID`, `AlbumID`, `SongID`를 활용해 데이터의 뼈대를 잡음.
- 가사, 재생시간, 소속사 등 실무에 필요한 속성(Field)들을 구체적으로 배치함.

### [그림 3: 실무형 확장 모델링]
- **Entertainment_Company 추가**: 가수의 소속 정보를 별도 관리하여 데이터 일관성 유지.
- **Genre 테이블 분리**: 장르를 텍스트가 아닌 독립 엔티티로 관리하여 통계 및 필터링 효율 극대화.
- **다대다 해결**: `Song_Singer`, `Album_Genre`, `Singer_Genre` 등을 통해 현실의 복잡한 비즈니스 로직을 완벽하게 구현함.

## 3. 실수/에러와 해결 과정

- **문제점**: 처음에는 Song 테이블에 SingerID를 하나만 넣으려다 보니, 듀엣곡 처리가 불가능한 구조였음.
- **해결**: 세 번째 설계안처럼 `Song_Singer`라는 연결 고리를 만들어 가수를 무제한으로 연결할 수 있게 개선함.
- **느낀점**: 데이터베이스 설계가 잘되어야 나중에 파이썬 로직을 짤 때 조건문이 복잡해지지 않는다는 것을 깨달음.

## 4. 실무/RAG 관점의 참견

- **데이터 풍부성**: `role(역할)`이나 `앨범 자켓 이미지` 같은 필드는 AI 서비스 UI 구성 시 사용자 경험을 풍부하게 해줌.
- **RAG 최적화**: 장르나 소속사 정보가 테이블로 분리되어 있으면, AI가 "특정 소속사의 발라드 곡만 분석해줘"라는 복잡한 쿼리를 더 정확하게 수행할 수 있음.

## 내가만든 ERD 이미지
(../images/Song_ERD.png)