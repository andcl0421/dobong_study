#### 1. 오늘 학습 요약 (핵심 정리)
객체 지향 프로그래밍(OOP)의 4대 요소 중 상속과 다형성을 자판기 예제로 실습함. 서로 다른 객체(VendingMachine, Product, Payment)가 유기적으로 연결되어 동작하는 시스템 설계 흐름을 파악함.

#### 2. 배운 개념 정리
- **매직 메서드(__str__)**: 객체를 문자열로 표현할 때 사용하며, 사용자에게 친숙한 정보를 전달하는 인터페이스 역할을 함.
- **상속**: 공통된 결제(Payment) 규격을 만들고 이를 확장하여 현금/카드 결제를 구현함.
- **다형성**: 자판기 입장에서는 어떤 결제 수단이 들어오든 `pay()`라는 동일한 메서드만 호출하면 되므로 확장이 용이함.

#### 3. 오늘 작성한 코드 리뷰
```python
class Product:
    def __init__(self, name, price, stock):
        self.name = name
        self.price = price
        self.stock = stock

    def __str__(self):
        # f-string을 이용한 가독성 높은 상품 정보 반환
        return f'{self.name}:{self.price}(재고 :{self.stock}개)'

class CashPayment:
    def __init__(self, money_valued):
        self.money_valued = money_valued

    def pay(self, price):
        # 결제 승인 여부(True/False)를 반환하는 핵심 비즈니스 로직
        return self.money_valued >= price

class VendingMachine:
    def dispense_product(self, name, payment):
        for product in self.inventory:
            if product.name == name:
                if product.stock <= 0: return  # 재고 부족 예외 처리
                if payment.pay(product.price): # 다형성을 이용한 결제 호출
                    product.stock -= 1         # 데이터 정합성 유지
                return
```

#### 4. 실수/에러와 해결 과정
- **문제**: `NameError: name 'CashPayment' is not defined` 발생.
- **원인**: 클래스 정의 시에는 소문자(`Cashpayment`)로, 호출 시에는 대문자(`CashPayment`)로 사용하여 이름이 불일치함.
- **해결**: 클래스 명명 규칙(PascalCase)에 따라 대문자로 통일하여 해결.

#### 5. 실무/RAG 관점의 참견
- 자판기 구조는 AI 에이전트의 '도구 호출(Tool Calling)' 구조와 흡사함.
- `payment.pay()`는 AI가 외부 API를 호출하여 결과를 받아오는 과정으로 치환 가능함.
- 실무에서는 상품 데이터 관리 시 리스트보다 딕셔너리(`{name: product_obj}`)를 사용하여 검색 속도($O(1)$)를 최적화함.


# 커밋 제목: 파이썬_기초_추상 클래스와 abstractmethod의 개념 및 활용

- abc 모듈의 ABCMeta와 abstractmethod 데코레이터를 활용한 추상화 구조 학습
- 부모 클래스에서 추상 메서드를 선언하여 자식 클래스의 메서드 구현을 강제함
- 추상 클래스 자체는 인스턴스화할 수 없다는 OOP의 핵심 제약 사항 확인

헷갈렸던 점:
- 추상 클래스로 직접 객체를 만들 수 없는 이유 (인스턴스화 불가)
- 상속받은 자식 클래스에서 부모의 추상 메서드를 반드시 오버라이딩해야 하는 강제성

