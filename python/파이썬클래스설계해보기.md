# :비디오_게임: 게임 캐릭터 시스템 설계 문서
## 1. 개요
이 문서는 객체지향 프로그래밍(OOP)을 활용하여
**게임 캐릭터, 직업(Job), 무기(Weapon)** 간의 관계를 설계하고 구현한 내용을 설명합니다.
핵심 개념:
- 다형성 (Polymorphism)
- 합성 (Composition)
- 추상 클래스 (Abstract Base Class)
---
## 2. 게임 세계관 규칙
### 2.1 캐릭터 생성 규칙
- 모든 캐릭터는 **이름(name)** 과 **역할(job)** 을 가지고 태어납니다.
- 이름이나 역할이 없으면 캐릭터는 생성될 수 없습니다.
---
### 2.2 전투 규칙 (다형성)
- 모든 캐릭터는 `attack()` 명령을 받습니다.
- 실제 공격 방식은 **직업(Job)** 에 따라 달라집니다.
| 직업 | 공격 방식 |
|----|----|
| 전사(Warrior) | 검을 휘두르는 물리 공격 |
| 마법사(Mage) | 주문을 외우는 마법 공격 |
:오른쪽을_가리키는_손_모양: 캐릭터가 어떤 무기를 들고 있는지와 무관하게
**공격 방식은 직업이 결정합니다.**
---
### 2.3 무기 장착 규칙
- 무기는 아무나 장착할 수 없습니다.
- 각 직업은 **허용된 무기 목록(allow_weapons)** 을 가집니다.
| 직업 | 사용 가능 무기 |
|----|----|
| 전사 | 검(Sword) |
| 마법사 | 지팡이(Wand) |
허용되지 않은 무기를 장착하려 하면 거절됩니다.
---
### 2.4 스킬 사용 규칙
- 무기에만 고유한 스킬이 존재합니다.
- 캐릭터는 **무기를 장착했을 때만** 스킬을 사용할 수 있습니다.
| 상태 | 결과 |
|----|----|
| 무기 있음 | 무기의 스킬 사용 |
| 무기 없음 | 스킬 사용 불가 |
---
## 3. 클래스 구조
### 3.1 Character 클래스
```python
class Character:
    def __init__(self, name, job):
        self.name = name
        self.job = job
        self.weapon = None
    def attack(self):
        print(self.name)
        self.job.attack()
    def equip_weapon(self, weapon):
        if not isinstance(weapon, tuple(self.job.allow_weapons)):
            print('착용 불가능합니다')
            return
        print(f'{weapon.name} 무기를 착용했습니다!')
        self.weapon = weapon
    def use_skill(self):
        if self.weapon is not None:
            self.weapon.skill()
        else:
            print('착용된 무기가 없어서 스킬 못써요!')
캐릭터는 직업과 무기를 가진다 (합성)
공격 방식은 job.attack() 에 위임
스킬 사용은 weapon.skill() 에 위임
3.2 Job 추상 클래스

from abc import ABC, abstractmethod
class Job(ABC):
    @abstractmethod
    def attack(self):
        pass
모든 직업은 반드시 attack() 을 구현해야 합니다.
Warrior


class Warrior(Job):
    allow_weapons = [Sword]
    def attack(self):
        print('전사의 공격')
Mage


class Mage(Job):
    allow_weapons = [Wand]
    def attack(self):
        print('마법사의 공격')
3.3 Weapon 추상 클래스

from abc import ABC, abstractmethod
class Weapon(ABC):
    def __init__(self, name):
        self.name = name
    @abstractmethod
    def skill(self):
        pass
Sword

class Sword(Weapon):
    def skill(self):
        print(f'울부짖어라 {self.name}')
Wand


class Wand(Weapon):
    def skill(self):
        print(f'흩날려라 {self.name}')
4. 실행 예제


me = Character('아서', Warrior())
you = Character('멀린', Mage())
sword = Sword('쌍고검')
wand = Wand('딱총나무 지팡이')
me.attack()
you.attack()
me.use_skill()
me.equip_weapon(sword)
me.use_skill()
me.equip_weapon(wand)
you.equip_weapon(wand)
me.job = Mage()
5. 객체지향 설계 요약
개념	적용 위치
다형성	job.attack()
합성	Character → Weapon
추상 클래스	Job, Weapon
책임 분리	공격 = Job / 스킬 = Weapon

6. 결론
이 설계는 게임 규칙을 객체지향적으로 명확하게 분리하여
확장성과 유지보수성이 높은 구조를 제공합니다.
새로운 직업 추가 
새로운 무기 추가 
기존 코드 수정 최소화 